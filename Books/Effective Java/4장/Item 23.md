## 태그 달린 클래스보다는 클래스 계층구조를 활용해라

- 태그 달린 클래스는 단점이 한가득이다.
- 태그 달린 클래스: 두 가지 이상의 의미를 표현할 수 있으며, 그 중 현재 표현하는 의미를 태그 값으로 알려주는 클래스

#### 태그 달린 클래스가 뭐지?

태그 달린 클래스는 하나의 클래스 내에서 객체의 종류를 구분하기 위해 태그(일반적으로 정수 또는 열거형 값)를 사용하는 디자인 패턴을 말한다.
이 패턴은 특정 기능 또는 유형의 객체를 구현하기 위해 클래스에 여러 태그 필드를 추가하고, 이 태그 값을 사용하여 객체의 종류를 식별한다.

```
class Shape {
    int tag; // 도형 종류를 식별하는 태그 (예: 1은 원, 2는 사각형)
    double radius; // 원의 반지름
    double width; // 사각형의 너비
    double height; // 사각형의 높이
}
```

이렇게 구현하기 때문에 태그 달린 클래스 패턴은 가독성과 유지보수성이 낮아지며, 객체의 종류가 늘어날 때 코드의 복잡성이 빠르게 증가할 수 있다. 또한 버그를 발생시키기 쉽다는 단점도 가지고 있다.

따라서 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.

### 태그 달린 클래스의 대안: 서브타이핑

- 객체 지향 언어는 타입 하나로 다양한 의미 객체를 표현하는 훨씬 나은 수단을 제공한다. **클래스 계층구조**를 활용하는 **서브 타이핑**이다.
- 서브 타이핑: 타입 계층을 구성하기 위해 상속을 사용
- 서브 클래싱: 다른 클래스 코드를 재사용하는 목적으로 상속을 사용


### 태그 달린 클래스를 클래스 계층구조로 바꾸는 방법

1. 계층구조의 루트가 될 추상 클래스를 정의한다.
2. 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언한다.
3. 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클래스에 일반 메서드로 추가한다.
4. 모든 하위 클래스에서 공동으로 사용하는 데이터 필드들도 전부 루트 클래스로 올린다.
5. 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의한다.
6. 루트 클래스가 정의한 추상 메서드를 각자의 의미에 맞게 구현한다.

```
abstract class Shape {
    abstract double calculateArea();
}

class Circle extends Shape {
    final double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    final double width;
    final double height;

    Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    double calculateArea() {
        return width * height;
    }
}
```

- shape 클래스는 도형을 나타내는 추상 클래스로, calculaterArea 라는 추상 메서드를 갖고 있다.
- circle 클래스는 shape 클래스를 확장하며, 원을 나타낸다. 반지름을 가지고 원의 넓이를 계산한는 구체적인 메서드를 구현한다.
- Rectangle 클래스는 역시 shape 클래스를 확장하며, 사각형을 나타낸다. 가로와 세로의 길이를 가지고 사각형의 넓이를 계산하는 구체적인 메서드를 구현한다.

#### 계층 구조의 장점

1. 코드가 간결하고 명확하다.
2. 쓸데없는 코드가 사라진다.
3. 각 클래스의 생성자가 모든 필드를 남김없이 초기화하고, 추상 메서드를 모두 구현했는지 컴파일러가 확인해준다.
4. 실수로 빼먹은 case문 때문에 런타임 오류를 발생할 일이 없다.
5. 루트 클래스의 코드를 건드리지 않고도 다른 프로그래머들이 독립적으로 계층구조를 확장하고 함께 사용할 수 있다.
6. 타입이 의미별로 따로 존재하여 변수의 의미를 명시하거나 제한할 수 있고, 특정 의미만 매개변수로 받을 수 있다.
7. 타입 사이의 자연스러운 계층 관계를 반영할수 있어서 유연성은 물론 컴파일 타입 검사 능력을 높여준다.